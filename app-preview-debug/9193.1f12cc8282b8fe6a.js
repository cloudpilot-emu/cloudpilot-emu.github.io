(()=>{"use strict";class n{constructor(s,t,a){this.capacity=s,this.sampleRateFrom=t,this.sampleRateTo=a,this.length=0,this.nextSample=0,this.currentSampleIndex=0,this.currentSampleLeft=0,this.currentSampleRight=0,this.channelLeftData=new Float32Array(this.capacity),this.channelRightData=new Float32Array(this.capacity)}push(s){this.channelLeftData[this.nextSample]=(s<<16>>16)/32767,this.channelRightData[this.nextSample]=(s>>16)/32767,this.length<this.capacity&&this.length++,this.nextSample=(this.nextSample+1)%this.capacity}fill(s,t){const a=s.length;if(a!==t.length)return;let e=(this.nextSample-this.length+this.capacity)%this.capacity;if(this.sampleRateFrom===this.sampleRateTo)for(let i=0;i<a&&this.length>0;i++)s[i]=this.channelLeftData[e],t[i]=this.channelRightData[e],e=(e+1)%this.capacity,this.length--;else for(let i=0;i<a&&this.length>0;i++){if(this.currentSampleIndex+=this.sampleRateFrom,this.currentSampleIndex>this.sampleRateTo){this.currentSampleLeft=this.channelLeftData[e],this.currentSampleRight=this.channelRightData[e];let r=this.currentSampleIndex/this.sampleRateTo|0;r>this.length&&(r=this.length),e=(e+r)%this.capacity,this.currentSampleIndex%=this.sampleRateTo,this.length-=r}s[i]=this.currentSampleLeft,t[i]=this.currentSampleRight}}clear(){this.length=0}}class l extends AudioWorkletProcessor{constructor(s){super(),this.onStreamMessage=a=>{const e=a.data;switch(e.type){case"sampleData":{const i=e.count,r=new Uint32Array(e.buffer);for(let h=0;h<i;h++)this.sampleQueue.push(r[h]);this.dispatchStreamMessage({type:"returnBuffer",buffer:e.buffer},[e.buffer]);break}case"flush":this.flush(),this.dispatchStreamMessage({type:"resumePcm"})}},this.onControlMessage=a=>{const e=a.data;switch(e.type){case"setStreamMessagePort":this.setStreamPort(e.port);break;case"flush":this.flush(),this.dispatchStreamMessage({type:"resumePcm"});break;case"reset":this.clearStreamPort()}},this.buffering=!0,this.backpressure=!1;const t=s.processorOptions.sampleRateTo;this.sampleQueue=new n(7350,44100,t),this.buffering=!0,this.backpressure=!1,this.port.addEventListener("message",this.onControlMessage),this.port.start(),console.log(`pcm worklet initialized at ${t}Hz`)}process(s,t){if(1!==t.length||2!==t[0].length)return!1;const a=t[0][0].length;return this.buffering&&this.sampleQueue.length>2940&&(this.buffering=!1),!this.buffering&&this.sampleQueue.length<a&&(this.buffering=!0),this.backpressure&&this.sampleQueue.length<5145&&(this.backpressure=!1,this.dispatchStreamMessage({type:"resumePcm"})),!this.backpressure&&this.sampleQueue.length>5880&&(this.backpressure=!0,this.dispatchStreamMessage({type:"suspendPcm"})),this.buffering||this.sampleQueue.fill(t[0][0],t[0][1]),!0}dispatchStreamMessage(s,t){this.streamPort?.postMessage(s,t)}flush(){this.buffering=!0,this.backpressure=!1,this.sampleQueue.clear()}clearStreamPort(){this.streamPort&&this.streamPort.removeEventListener("message",this.onStreamMessage),this.streamPort=void 0,this.flush()}setStreamPort(s){this.clearStreamPort(),this.streamPort=s,this.streamPort.addEventListener("message",this.onStreamMessage),this.streamPort.start()}}registerProcessor("pcm-processor",l)})();
//# sourceMappingURL=9193.1f12cc8282b8fe6a.js.map