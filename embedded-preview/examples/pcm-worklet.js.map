{"version":3,"file":"pcm-worklet.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAoB,WAAID,IAExBD,EAAiB,WAAIC,GACtB,CATD,CASGK,KAAM,I,mBCMT,MAAMC,EACF,WAAAC,CACYC,EACAC,EACAC,GAFA,KAAAF,SAAAA,EACA,KAAAC,eAAAA,EACA,KAAAC,aAAAA,EAyDZ,KAAAC,OAAS,EACD,KAAAC,WAAa,EAKb,KAAAC,mBAAqB,EACrB,KAAAC,kBAAoB,EACpB,KAAAC,mBAAqB,EA/DzBC,KAAKC,gBAAkB,IAAIC,aAAaF,KAAKR,UAC7CQ,KAAKG,iBAAmB,IAAID,aAAaF,KAAKR,SAClD,CAEA,IAAAY,CAAKC,GACDL,KAAKC,gBAAgBD,KAAKJ,aAAgBS,GAAU,IAAO,IAAM,MACjEL,KAAKG,iBAAiBH,KAAKJ,aAAeS,GAAU,IAAM,MAEtDL,KAAKL,OAASK,KAAKR,UACnBQ,KAAKL,SAGTK,KAAKJ,YAAcI,KAAKJ,WAAa,GAAKI,KAAKR,QACnD,CAEA,IAAAc,CAAKC,EAA2BC,GAC5B,MAAMb,EAASY,EAAYZ,OAC3B,GAAIA,IAAWa,EAAab,OAAQ,OAEpC,IAAIc,GAAOT,KAAKJ,WAAaI,KAAKL,OAASK,KAAKR,UAAYQ,KAAKR,SAEjE,GAAIQ,KAAKP,iBAAmBO,KAAKN,aAC7B,IAAK,IAAIgB,EAAO,EAAGA,EAAOf,GAAUK,KAAKL,OAAS,EAAGe,IACjDH,EAAYG,GAAQV,KAAKC,gBAAgBQ,GACzCD,EAAaE,GAAQV,KAAKG,iBAAiBM,GAE3CA,GAAOA,EAAM,GAAKT,KAAKR,SACvBQ,KAAKL,cAGT,IAAK,IAAIe,EAAO,EAAGA,EAAOf,GAAUK,KAAKL,OAAS,EAAGe,IAAQ,CAGzD,GAFAV,KAAKH,oBAAsBG,KAAKP,eAE5BO,KAAKH,mBAAqBG,KAAKN,aAAc,CAC7CM,KAAKF,kBAAoBE,KAAKC,gBAAgBQ,GAC9CT,KAAKD,mBAAqBC,KAAKG,iBAAiBM,GAEhD,IAAIE,EAAaX,KAAKH,mBAAqBG,KAAKN,aAAgB,EAC5DiB,EAAYX,KAAKL,SAAQgB,EAAYX,KAAKL,QAE9Cc,GAAOA,EAAME,GAAaX,KAAKR,SAC/BQ,KAAKH,oBAAsBG,KAAKN,aAChCM,KAAKL,QAAUgB,CACnB,CAEAJ,EAAYG,GAAQV,KAAKF,kBACzBU,EAAaE,GAAQV,KAAKD,kBAC9B,CAER,CAEA,KAAAa,GACIZ,KAAKL,OAAS,CAClB,EAaJ,MAAMkB,UAAqBC,sBACvB,WAAAvB,CAAYwB,GACRC,QA6CI,KAAAC,gBAAmBC,IACvB,MAAMC,EAA6BD,EAAEE,KAErC,OAAQD,EAAQE,MACZ,IAAK,aAAkC,CACnC,MAAMC,EAAQH,EAAQG,MAChBC,EAAU,IAAIC,YAAYL,EAAQM,QAExC,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAOI,IAAK1B,KAAK2B,YAAYvB,KAAKmB,EAAQG,IAE9D1B,KAAK4B,sBAAsB,CAAEP,KAAM,eAAsCI,OAAQN,EAAQM,QAAU,CAC/FN,EAAQM,SAGZ,KACJ,CAEA,IAAK,QACDzB,KAAK6B,QACL7B,KAAK4B,sBAAsB,CAAEP,KAAM,gBASvC,KAAAS,iBAAoBZ,IACxB,MAAMC,EAA8BD,EAAEE,KAEtC,OAAQD,EAAQE,MACZ,IAAK,uBACDrB,KAAK+B,cAAcZ,EAAQa,MAC3B,MAGJ,IAAK,QACDhC,KAAK6B,QACL7B,KAAK4B,sBAAsB,CAAEP,KAAM,cAEnC,MAEJ,IAAK,QACDrB,KAAKiC,oBAgCT,KAAAC,WAAY,EACZ,KAAAC,cAAe,EAxHnB,MAAMzC,EAAeqB,EAAQqB,iBAAiB1C,aAE9CM,KAAK2B,YAAc,IAAIrC,EAAY,KAAmB,MAAOI,GAC7DM,KAAKkC,WAAY,EACjBlC,KAAKmC,cAAe,EAEpBnC,KAAKgC,KAAKK,iBAAiB,UAAWrC,KAAK8B,kBAC3C9B,KAAKgC,KAAKM,QAEVC,QAAQC,IAAI,8BAA8B9C,MAC9C,CAEA,OAAA+C,CAAQC,EAA0BC,GAC9B,GAAuB,IAAnBA,EAAQhD,QAAsC,IAAtBgD,EAAQ,GAAGhD,OAAc,OAAO,EAC5D,MAAMiD,EAAMD,EAAQ,GAAG,GAAGhD,OAsB1B,OApBIK,KAAKkC,WAAalC,KAAK2B,YAAYhC,OAAS,OAC5CK,KAAKkC,WAAY,IAGhBlC,KAAKkC,WAAalC,KAAK2B,YAAYhC,OAASiD,IAC7C5C,KAAKkC,WAAY,GAGjBlC,KAAKmC,cAAgBnC,KAAK2B,YAAYhC,OAAS,OAC/CK,KAAKmC,cAAe,EACpBnC,KAAK4B,sBAAsB,CAAEP,KAAM,gBAGlCrB,KAAKmC,cAAgBnC,KAAK2B,YAAYhC,OAAS,OAChDK,KAAKmC,cAAe,EACpBnC,KAAK4B,sBAAsB,CAAEP,KAAM,gBAGlCrB,KAAKkC,WAAWlC,KAAK2B,YAAYrB,KAAKqC,EAAQ,GAAG,GAAIA,EAAQ,GAAG,KAE9D,CACX,CAEQ,qBAAAf,CAAsBT,EAA8B0B,G,MACzC,QAAf,EAAA7C,KAAK8C,kBAAU,SAAEC,YAAY5B,EAAS0B,EAC1C,CAuDQ,KAAAhB,GACJ7B,KAAKkC,WAAY,EACjBlC,KAAKmC,cAAe,EAEpBnC,KAAK2B,YAAYf,OACrB,CAEQ,eAAAqB,GACAjC,KAAK8C,YAAY9C,KAAK8C,WAAWE,oBAAoB,UAAWhD,KAAKiB,iBACzEjB,KAAK8C,gBAAaG,EAElBjD,KAAK6B,OACT,CAEQ,aAAAE,CAAcC,GAClBhC,KAAKiC,kBAELjC,KAAK8C,WAAad,EAClBhC,KAAK8C,WAAWT,iBAAiB,UAAWrC,KAAKiB,iBACjDjB,KAAK8C,WAAWR,OACpB,E,OASJY,kBAAkB,gBAA0BrC,G","sources":["webpack://cloudpilot/webpack/universalModuleDefinition","webpack://cloudpilot/./common/service/audioworklet/pcm-worklet.worker.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cloudpilot\"] = factory();\n\telse\n\t\troot[\"cloudpilot\"] = factory();\n})(self, () => {\nreturn ","/// <reference lib=\"webworker\" />\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"./audioworklet.d.ts\"/>\n//\nimport {\n    ControlMessageHost,\n    ControlMessageHostType,\n    StreamMessageClient,\n    StreamMessageClientType,\n    StreamMessageHost,\n    StreamMessageHostType,\n} from './messages';\nimport { PcmProcessorOptions, ProcessorNodeOptions } from './options';\nimport { WorkletType } from './worklet-types';\n\nclass SampleQueue {\n    constructor(\n        private capacity: number,\n        private sampleRateFrom: number,\n        private sampleRateTo: number,\n    ) {\n        this.channelLeftData = new Float32Array(this.capacity);\n        this.channelRightData = new Float32Array(this.capacity);\n    }\n\n    push(sample: number) {\n        this.channelLeftData[this.nextSample] = ((sample << 16) >> 16) / 0x7fff;\n        this.channelRightData[this.nextSample] = (sample >> 16) / 0x7fff;\n\n        if (this.length < this.capacity) {\n            this.length++;\n        }\n\n        this.nextSample = (this.nextSample + 1) % this.capacity;\n    }\n\n    fill(channelLeft: Float32Array, channelRight: Float32Array) {\n        const length = channelLeft.length;\n        if (length !== channelRight.length) return;\n\n        let iIn = (this.nextSample - this.length + this.capacity) % this.capacity;\n\n        if (this.sampleRateFrom === this.sampleRateTo) {\n            for (let iOut = 0; iOut < length && this.length > 0; iOut++) {\n                channelLeft[iOut] = this.channelLeftData[iIn];\n                channelRight[iOut] = this.channelRightData[iIn];\n\n                iIn = (iIn + 1) % this.capacity;\n                this.length--;\n            }\n        } else {\n            for (let iOut = 0; iOut < length && this.length > 0; iOut++) {\n                this.currentSampleIndex += this.sampleRateFrom;\n\n                if (this.currentSampleIndex > this.sampleRateTo) {\n                    this.currentSampleLeft = this.channelLeftData[iIn];\n                    this.currentSampleRight = this.channelRightData[iIn];\n\n                    let increment = (this.currentSampleIndex / this.sampleRateTo) | 0;\n                    if (increment > this.length) increment = this.length;\n\n                    iIn = (iIn + increment) % this.capacity;\n                    this.currentSampleIndex %= this.sampleRateTo;\n                    this.length -= increment;\n                }\n\n                channelLeft[iOut] = this.currentSampleLeft;\n                channelRight[iOut] = this.currentSampleRight;\n            }\n        }\n    }\n\n    clear() {\n        this.length = 0;\n    }\n\n    length = 0;\n    private nextSample = 0;\n\n    private channelLeftData: Float32Array;\n    private channelRightData: Float32Array;\n\n    private currentSampleIndex = 0;\n    private currentSampleLeft = 0;\n    private currentSampleRight = 0;\n}\n\nclass PcmProcessor extends AudioWorkletProcessor implements AudioWorkletProcessorImpl {\n    constructor(options: ProcessorNodeOptions<PcmProcessorOptions>) {\n        super();\n\n        const sampleRateTo = options.processorOptions.sampleRateTo;\n\n        this.sampleQueue = new SampleQueue((44100 / 60) * 10, 44100, sampleRateTo);\n        this.buffering = true;\n        this.backpressure = false;\n\n        this.port.addEventListener('message', this.onControlMessage);\n        this.port.start();\n\n        console.log(`pcm worklet initialized at ${sampleRateTo}Hz`);\n    }\n\n    process(inputs: Float32Array[][], outputs: Float32Array[][]): boolean {\n        if (outputs.length !== 1 || outputs[0].length !== 2) return false;\n        const len = outputs[0][0].length;\n\n        if (this.buffering && this.sampleQueue.length > (44100 / 60) * 4) {\n            this.buffering = false;\n        }\n\n        if (!this.buffering && this.sampleQueue.length < len) {\n            this.buffering = true;\n        }\n\n        if (this.backpressure && this.sampleQueue.length < (44100 / 60) * 7) {\n            this.backpressure = false;\n            this.dispatchStreamMessage({ type: StreamMessageClientType.resumePcm });\n        }\n\n        if (!this.backpressure && this.sampleQueue.length > (44100 / 60) * 8) {\n            this.backpressure = true;\n            this.dispatchStreamMessage({ type: StreamMessageClientType.suspendPcm });\n        }\n\n        if (!this.buffering) this.sampleQueue.fill(outputs[0][0], outputs[0][1]);\n\n        return true;\n    }\n\n    private dispatchStreamMessage(message: StreamMessageClient, transferables?: Array<Transferable>) {\n        this.streamPort?.postMessage(message, transferables as Array<Transferable>);\n    }\n\n    private onStreamMessage = (e: MessageEvent) => {\n        const message: StreamMessageHost = e.data;\n\n        switch (message.type) {\n            case StreamMessageHostType.sampleData: {\n                const count = message.count;\n                const samples = new Uint32Array(message.buffer);\n\n                for (let i = 0; i < count; i++) this.sampleQueue.push(samples[i]);\n\n                this.dispatchStreamMessage({ type: StreamMessageClientType.returnBuffer, buffer: message.buffer }, [\n                    message.buffer,\n                ]);\n\n                break;\n            }\n\n            case StreamMessageHostType.flush:\n                this.flush();\n                this.dispatchStreamMessage({ type: StreamMessageClientType.resumePcm });\n\n                break;\n\n            default:\n                message satisfies never;\n        }\n    };\n\n    private onControlMessage = (e: MessageEvent) => {\n        const message: ControlMessageHost = e.data;\n\n        switch (message.type) {\n            case ControlMessageHostType.setStreamMessagePort: {\n                this.setStreamPort(message.port);\n                break;\n            }\n\n            case ControlMessageHostType.flush:\n                this.flush();\n                this.dispatchStreamMessage({ type: StreamMessageClientType.resumePcm });\n\n                break;\n\n            case ControlMessageHostType.reset:\n                this.clearStreamPort();\n\n                break;\n\n            default:\n                message satisfies never;\n        }\n    };\n\n    private flush(): void {\n        this.buffering = true;\n        this.backpressure = false;\n\n        this.sampleQueue.clear();\n    }\n\n    private clearStreamPort(): void {\n        if (this.streamPort) this.streamPort.removeEventListener('message', this.onStreamMessage);\n        this.streamPort = undefined;\n\n        this.flush();\n    }\n\n    private setStreamPort(port: MessagePort): void {\n        this.clearStreamPort();\n\n        this.streamPort = port;\n        this.streamPort.addEventListener('message', this.onStreamMessage);\n        this.streamPort.start();\n    }\n\n    private sampleQueue: SampleQueue;\n    private buffering = true;\n    private backpressure = false;\n\n    private streamPort: MessagePort | undefined;\n}\n\nregisterProcessor(WorkletType.pcmProcessor, PcmProcessor);\n"],"names":["root","factory","exports","module","define","amd","self","SampleQueue","constructor","capacity","sampleRateFrom","sampleRateTo","length","nextSample","currentSampleIndex","currentSampleLeft","currentSampleRight","this","channelLeftData","Float32Array","channelRightData","push","sample","fill","channelLeft","channelRight","iIn","iOut","increment","clear","PcmProcessor","AudioWorkletProcessor","options","super","onStreamMessage","e","message","data","type","count","samples","Uint32Array","buffer","i","sampleQueue","dispatchStreamMessage","flush","onControlMessage","setStreamPort","port","clearStreamPort","buffering","backpressure","processorOptions","addEventListener","start","console","log","process","inputs","outputs","len","transferables","streamPort","postMessage","removeEventListener","undefined","registerProcessor"],"sourceRoot":""}