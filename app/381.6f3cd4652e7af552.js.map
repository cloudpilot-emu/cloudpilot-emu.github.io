{"version":3,"file":"381.6f3cd4652e7af552.js","mappings":"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","names":["hostContext","selector","el","closest","createColorClasses","color","cssClassMap","length","Object","assign","getClassMap","classes","map","getClassList","undefined","Array","isArray","split","filter","c","trim","forEach","SCHEME","openURL","_ref","_asyncToGenerator","url","ev","direction","animation","test","router","document","querySelector","preventDefault","push","_x","_x2","_x3","_x4","apply","this","arguments","InputOTP","constructor","hostRef","registerInstance","ionInput","createEvent","ionChange","ionComplete","ionBlur","ionFocus","inheritedAttributes","inputRefs","inputId","inputIds","parsedSeparators","isKeyboardNavigation","inputValues","hasFocus","previousInputValues","autocapitalize","disabled","fill","readonly","shape","size","type","value","onFocus","index","event","_a","emit","focusedValue","finalIndex","targetIndex","getFirstEmptyIndex","focus","input","i","tabIndex","onBlur","relatedTarget","includes","updateTabIndexes","emitIonChange","onKeyDown","rtl","isRTL","target","selectionStart","selectionEnd","metaKey","ctrlKey","key","toLowerCase","updateValue","focusPrevious","isLeft","focusNext","onInput","_b","validKeyPattern","previousValue","validChars","char","slice","requestAnimationFrame","setTimeout","newChar","data","find","onPaste","pastedText","clipboardData","getData","emitIonInput","join","setFocus","_this","validIndex","Math","max","min","tabbableIndex","getTabbableIndex","valueChanged","initializeValues","processSeparators","separators","printIonWarning","separatorValues","from","_","pos","parseInt","isNaN","indexOf","invalidSeparators","componentWillLoad","inheritAriaAttributes","componentDidLoad","RegExp","getPattern","pattern","getInputmode","inputmode","String","newValue","toString","currentIndex","findIndex","firstEmptyIndex","shouldBeTabbable","setAttribute","showSeparator","render","mode","getIonMode","hasDescription","textContent","h","Host","class","y","role","Fragment","id","autoCapitalize","readOnly","autocomplete","ref","getElement","watchers","style","ios","md"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/@ionic/core/dist/esm/theme-DiVJyqlX.js","./node_modules/@ionic/core/dist/esm/ion-input-otp.entry.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nconst hostContext = (selector, el) => {\n    return el.closest(selector) !== null;\n};\n/**\n * Create the mode and color classes for the component based on the classes passed in\n */\nconst createColorClasses = (color, cssClassMap) => {\n    return typeof color === 'string' && color.length > 0\n        ? Object.assign({ 'ion-color': true, [`ion-color-${color}`]: true }, cssClassMap) : cssClassMap;\n};\nconst getClassList = (classes) => {\n    if (classes !== undefined) {\n        const array = Array.isArray(classes) ? classes : classes.split(' ');\n        return array\n            .filter((c) => c != null)\n            .map((c) => c.trim())\n            .filter((c) => c !== '');\n    }\n    return [];\n};\nconst getClassMap = (classes) => {\n    const map = {};\n    getClassList(classes).forEach((c) => (map[c] = true));\n    return map;\n};\nconst SCHEME = /^[a-z][a-z0-9+\\-.]*:/;\nconst openURL = async (url, ev, direction, animation) => {\n    if (url != null && url[0] !== '#' && !SCHEME.test(url)) {\n        const router = document.querySelector('ion-router');\n        if (router) {\n            if (ev != null) {\n                ev.preventDefault();\n            }\n            return router.push(url, direction, animation);\n        }\n    }\n    return false;\n};\n\nexport { createColorClasses as c, getClassMap as g, hostContext as h, openURL as o };\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { r as registerInstance, c as createEvent, f as printIonWarning, h, F as Fragment, d as Host, g as getElement } from './index-4DxY6_gG.js';\nimport { i as inheritAriaAttributes } from './helpers-8KSQQGQy.js';\nimport { i as isRTL } from './dir-C53feagD.js';\nimport { c as createColorClasses } from './theme-DiVJyqlX.js';\nimport { b as getIonMode } from './ionic-global-CTSyufhF.js';\n\nconst inputOtpIosCss = \".sc-ion-input-otp-ios-h{--margin-top:0;--margin-end:0;--margin-bottom:0;--margin-start:0;--padding-top:16px;--padding-end:0;--padding-bottom:16px;--padding-start:0;--color:initial;--min-width:40px;--separator-width:8px;--separator-height:var(--separator-width);--separator-border-radius:999px;--separator-color:var(--ion-color-step-150, var(--ion-background-color-step-150, #d9d9d9));--highlight-color-focused:var(--ion-color-primary, #0054e9);--highlight-color-valid:var(--ion-color-success, #2dd55b);--highlight-color-invalid:var(--ion-color-danger, #c5000f);--highlight-color:var(--highlight-color-focused);display:block;position:relative;font-size:0.875rem}.input-otp-group.sc-ion-input-otp-ios{-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center}.native-wrapper.sc-ion-input-otp-ios{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;min-width:var(--min-width)}.native-input.sc-ion-input-otp-ios{border-radius:var(--border-radius);width:var(--width);min-width:inherit;height:var(--height);border-width:var(--border-width);border-style:solid;border-color:var(--border-color);background:var(--background);color:var(--color);font-size:inherit;text-align:center;-webkit-appearance:none;-moz-appearance:none;appearance:none}.has-focus.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios{caret-color:var(--highlight-color)}.input-otp-description.sc-ion-input-otp-ios{color:var(--ion-color-step-700, var(--ion-text-color-step-300, #4d4d4d));font-size:0.75rem;line-height:1.25rem;text-align:center}.input-otp-description-hidden.sc-ion-input-otp-ios{display:none}.input-otp-separator.sc-ion-input-otp-ios{border-radius:var(--separator-border-radius);-ms-flex-negative:0;flex-shrink:0;width:var(--separator-width);height:var(--separator-height);background:var(--separator-color)}.input-otp-size-small.sc-ion-input-otp-ios-h{--width:40px;--height:40px}.input-otp-size-small.sc-ion-input-otp-ios-h .input-otp-group.sc-ion-input-otp-ios{gap:8px}.input-otp-size-medium.sc-ion-input-otp-ios-h{--width:48px;--height:48px}.input-otp-size-large.sc-ion-input-otp-ios-h{--width:56px;--height:56px}.input-otp-size-medium.sc-ion-input-otp-ios-h .input-otp-group.sc-ion-input-otp-ios,.input-otp-size-large.sc-ion-input-otp-ios-h .input-otp-group.sc-ion-input-otp-ios{gap:12px}.input-otp-shape-round.sc-ion-input-otp-ios-h{--border-radius:16px}.input-otp-shape-soft.sc-ion-input-otp-ios-h{--border-radius:8px}.input-otp-shape-rectangular.sc-ion-input-otp-ios-h{--border-radius:0}.input-otp-fill-outline.sc-ion-input-otp-ios-h{--background:none}.input-otp-fill-solid.sc-ion-input-otp-ios-h{--border-color:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2));--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2))}.input-otp-disabled.sc-ion-input-otp-ios-h{--color:var(--ion-color-step-350, var(--ion-text-color-step-650, #a6a6a6))}.input-otp-fill-outline.input-otp-disabled.sc-ion-input-otp-ios-h{--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2));--border-color:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6))}.input-otp-disabled.sc-ion-input-otp-ios-h,.input-otp-disabled.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios:disabled{cursor:not-allowed}.has-focus.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios:focus{--border-color:var(--highlight-color);outline:none}.input-otp-fill-outline.input-otp-readonly.sc-ion-input-otp-ios-h{--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2))}.input-otp-fill-solid.input-otp-disabled.sc-ion-input-otp-ios-h,.input-otp-fill-solid.input-otp-readonly.sc-ion-input-otp-ios-h{--border-color:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6));--background:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6))}.ion-touched.ion-invalid.sc-ion-input-otp-ios-h{--highlight-color:var(--highlight-color-invalid)}.ion-valid.sc-ion-input-otp-ios-h{--highlight-color:var(--highlight-color-valid)}.has-focus.ion-valid.sc-ion-input-otp-ios-h,.ion-touched.ion-invalid.sc-ion-input-otp-ios-h{--border-color:var(--highlight-color)}.ion-color.sc-ion-input-otp-ios-h{--highlight-color-focused:var(--ion-color-base)}.input-otp-fill-outline.ion-color.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-solid.ion-color.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios:focus{border-color:rgba(var(--ion-color-base-rgb), 0.6)}.input-otp-fill-outline.ion-color.ion-invalid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-solid.ion-color.ion-invalid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-outline.ion-color.has-focus.ion-invalid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-solid.ion-color.has-focus.ion-invalid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios{border-color:var(--ion-color-danger, #c5000f)}.input-otp-fill-outline.ion-color.ion-valid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-solid.ion-color.ion-valid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-outline.ion-color.has-focus.ion-valid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-solid.ion-color.has-focus.ion-valid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios{border-color:var(--ion-color-success, #2dd55b)}.input-otp-fill-outline.input-otp-disabled.ion-color.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios{border-color:rgba(var(--ion-color-base-rgb), 0.3)}.sc-ion-input-otp-ios-h{--border-width:0.55px}.has-focus.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios:focus{--border-width:1px}.input-otp-fill-outline.sc-ion-input-otp-ios-h{--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, var(--ion-background-color-step-250, #c8c7cc))))}\";\n\nconst inputOtpMdCss = \".sc-ion-input-otp-md-h{--margin-top:0;--margin-end:0;--margin-bottom:0;--margin-start:0;--padding-top:16px;--padding-end:0;--padding-bottom:16px;--padding-start:0;--color:initial;--min-width:40px;--separator-width:8px;--separator-height:var(--separator-width);--separator-border-radius:999px;--separator-color:var(--ion-color-step-150, var(--ion-background-color-step-150, #d9d9d9));--highlight-color-focused:var(--ion-color-primary, #0054e9);--highlight-color-valid:var(--ion-color-success, #2dd55b);--highlight-color-invalid:var(--ion-color-danger, #c5000f);--highlight-color:var(--highlight-color-focused);display:block;position:relative;font-size:0.875rem}.input-otp-group.sc-ion-input-otp-md{-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center}.native-wrapper.sc-ion-input-otp-md{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;min-width:var(--min-width)}.native-input.sc-ion-input-otp-md{border-radius:var(--border-radius);width:var(--width);min-width:inherit;height:var(--height);border-width:var(--border-width);border-style:solid;border-color:var(--border-color);background:var(--background);color:var(--color);font-size:inherit;text-align:center;-webkit-appearance:none;-moz-appearance:none;appearance:none}.has-focus.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md{caret-color:var(--highlight-color)}.input-otp-description.sc-ion-input-otp-md{color:var(--ion-color-step-700, var(--ion-text-color-step-300, #4d4d4d));font-size:0.75rem;line-height:1.25rem;text-align:center}.input-otp-description-hidden.sc-ion-input-otp-md{display:none}.input-otp-separator.sc-ion-input-otp-md{border-radius:var(--separator-border-radius);-ms-flex-negative:0;flex-shrink:0;width:var(--separator-width);height:var(--separator-height);background:var(--separator-color)}.input-otp-size-small.sc-ion-input-otp-md-h{--width:40px;--height:40px}.input-otp-size-small.sc-ion-input-otp-md-h .input-otp-group.sc-ion-input-otp-md{gap:8px}.input-otp-size-medium.sc-ion-input-otp-md-h{--width:48px;--height:48px}.input-otp-size-large.sc-ion-input-otp-md-h{--width:56px;--height:56px}.input-otp-size-medium.sc-ion-input-otp-md-h .input-otp-group.sc-ion-input-otp-md,.input-otp-size-large.sc-ion-input-otp-md-h .input-otp-group.sc-ion-input-otp-md{gap:12px}.input-otp-shape-round.sc-ion-input-otp-md-h{--border-radius:16px}.input-otp-shape-soft.sc-ion-input-otp-md-h{--border-radius:8px}.input-otp-shape-rectangular.sc-ion-input-otp-md-h{--border-radius:0}.input-otp-fill-outline.sc-ion-input-otp-md-h{--background:none}.input-otp-fill-solid.sc-ion-input-otp-md-h{--border-color:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2));--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2))}.input-otp-disabled.sc-ion-input-otp-md-h{--color:var(--ion-color-step-350, var(--ion-text-color-step-650, #a6a6a6))}.input-otp-fill-outline.input-otp-disabled.sc-ion-input-otp-md-h{--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2));--border-color:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6))}.input-otp-disabled.sc-ion-input-otp-md-h,.input-otp-disabled.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md:disabled{cursor:not-allowed}.has-focus.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md:focus{--border-color:var(--highlight-color);outline:none}.input-otp-fill-outline.input-otp-readonly.sc-ion-input-otp-md-h{--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2))}.input-otp-fill-solid.input-otp-disabled.sc-ion-input-otp-md-h,.input-otp-fill-solid.input-otp-readonly.sc-ion-input-otp-md-h{--border-color:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6));--background:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6))}.ion-touched.ion-invalid.sc-ion-input-otp-md-h{--highlight-color:var(--highlight-color-invalid)}.ion-valid.sc-ion-input-otp-md-h{--highlight-color:var(--highlight-color-valid)}.has-focus.ion-valid.sc-ion-input-otp-md-h,.ion-touched.ion-invalid.sc-ion-input-otp-md-h{--border-color:var(--highlight-color)}.ion-color.sc-ion-input-otp-md-h{--highlight-color-focused:var(--ion-color-base)}.input-otp-fill-outline.ion-color.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-solid.ion-color.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md:focus{border-color:rgba(var(--ion-color-base-rgb), 0.6)}.input-otp-fill-outline.ion-color.ion-invalid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-solid.ion-color.ion-invalid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-outline.ion-color.has-focus.ion-invalid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-solid.ion-color.has-focus.ion-invalid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md{border-color:var(--ion-color-danger, #c5000f)}.input-otp-fill-outline.ion-color.ion-valid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-solid.ion-color.ion-valid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-outline.ion-color.has-focus.ion-valid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-solid.ion-color.has-focus.ion-valid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md{border-color:var(--ion-color-success, #2dd55b)}.input-otp-fill-outline.input-otp-disabled.ion-color.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md{border-color:rgba(var(--ion-color-base-rgb), 0.3)}.sc-ion-input-otp-md-h{--border-width:1px}.has-focus.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md:focus{--border-width:2px}.input-otp-fill-outline.sc-ion-input-otp-md-h{--border-color:var(--ion-color-step-300, var(--ion-background-color-step-300, #b3b3b3))}\";\n\nconst InputOTP = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        this.ionInput = createEvent(this, \"ionInput\", 7);\n        this.ionChange = createEvent(this, \"ionChange\", 7);\n        this.ionComplete = createEvent(this, \"ionComplete\", 7);\n        this.ionBlur = createEvent(this, \"ionBlur\", 7);\n        this.ionFocus = createEvent(this, \"ionFocus\", 7);\n        this.inheritedAttributes = {};\n        this.inputRefs = [];\n        this.inputId = `ion-input-otp-${inputIds++}`;\n        this.parsedSeparators = [];\n        /**\n         * Tracks whether the user is navigating through input boxes using keyboard navigation\n         * (arrow keys, tab) versus mouse clicks. This is used to determine the appropriate\n         * focus behavior when an input box is focused.\n         */\n        this.isKeyboardNavigation = false;\n        this.inputValues = [];\n        this.hasFocus = false;\n        this.previousInputValues = [];\n        /**\n         * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user.\n         * Available options: `\"off\"`, `\"none\"`, `\"on\"`, `\"sentences\"`, `\"words\"`, `\"characters\"`.\n         */\n        this.autocapitalize = 'off';\n        /**\n         * If `true`, the user cannot interact with the input.\n         */\n        this.disabled = false;\n        /**\n         * The fill for the input boxes. If `\"solid\"` the input boxes will have a background. If\n         * `\"outline\"` the input boxes will be transparent with a border.\n         */\n        this.fill = 'outline';\n        /**\n         * The number of input boxes to display.\n         */\n        this.length = 4;\n        /**\n         * If `true`, the user cannot modify the value.\n         */\n        this.readonly = false;\n        /**\n         * The shape of the input boxes.\n         * If \"round\" they will have an increased border radius.\n         * If \"rectangular\" they will have no border radius.\n         * If \"soft\" they will have a soft border radius.\n         */\n        this.shape = 'round';\n        /**\n         * The size of the input boxes.\n         */\n        this.size = 'medium';\n        /**\n         * The type of input allowed in the input boxes.\n         */\n        this.type = 'number';\n        /**\n         * The value of the input group.\n         */\n        this.value = '';\n        /**\n         * Handles the focus behavior for the input OTP component.\n         *\n         * Focus behavior:\n         * 1. Keyboard navigation: Allow normal focus movement\n         * 2. Mouse click:\n         *    - If clicked box has value: Focus that box\n         *    - If clicked box is empty: Focus first empty box\n         *\n         * Emits the `ionFocus` event when the input group gains focus.\n         */\n        this.onFocus = (index) => (event) => {\n            var _a;\n            const { inputRefs } = this;\n            // Only emit ionFocus and set the focusedValue when the\n            // component first gains focus\n            if (!this.hasFocus) {\n                this.ionFocus.emit(event);\n                this.focusedValue = this.value;\n            }\n            this.hasFocus = true;\n            let finalIndex = index;\n            if (!this.isKeyboardNavigation) {\n                // If the clicked box has a value, focus it\n                // Otherwise focus the first empty box\n                const targetIndex = this.inputValues[index] ? index : this.getFirstEmptyIndex();\n                finalIndex = targetIndex === -1 ? this.length - 1 : targetIndex;\n                // Focus the target box\n                (_a = this.inputRefs[finalIndex]) === null || _a === void 0 ? void 0 : _a.focus();\n            }\n            // Update tabIndexes to match the focused box\n            inputRefs.forEach((input, i) => {\n                input.tabIndex = i === finalIndex ? 0 : -1;\n            });\n            // Reset the keyboard navigation flag\n            this.isKeyboardNavigation = false;\n        };\n        /**\n         * Handles the blur behavior for the input OTP component.\n         * Emits the `ionBlur` event when the input group loses focus.\n         */\n        this.onBlur = (event) => {\n            const { inputRefs } = this;\n            const relatedTarget = event.relatedTarget;\n            // Do not emit blur if we're moving to another input box in the same component\n            const isInternalFocus = relatedTarget != null && inputRefs.includes(relatedTarget);\n            if (!isInternalFocus) {\n                this.hasFocus = false;\n                // Reset tabIndexes when focus leaves the component\n                this.updateTabIndexes();\n                // Always emit ionBlur when focus leaves the component\n                this.ionBlur.emit(event);\n                // Only emit ionChange if the value has actually changed\n                if (this.focusedValue !== this.value) {\n                    this.emitIonChange(event);\n                }\n            }\n        };\n        /**\n         * Handles keyboard navigation for the OTP component.\n         *\n         * Navigation:\n         * - Backspace: Clears current input and moves to previous box if empty\n         * - Arrow Left/Right: Moves focus between input boxes\n         * - Tab: Allows normal tab navigation between components\n         */\n        this.onKeyDown = (index) => (event) => {\n            const { length } = this;\n            const rtl = isRTL(this.el);\n            const input = event.target;\n            // Meta shortcuts are used to copy, paste, and select text\n            // We don't want to handle these keys here\n            const metaShortcuts = ['a', 'c', 'v', 'x', 'r', 'z', 'y'];\n            const isTextSelection = input.selectionStart !== input.selectionEnd;\n            // Return if the key is a meta shortcut or the input value\n            // text is selected and let the onPaste / onInput handler manage it\n            if (isTextSelection || ((event.metaKey || event.ctrlKey) && metaShortcuts.includes(event.key.toLowerCase()))) {\n                return;\n            }\n            if (event.key === 'Backspace') {\n                if (this.inputValues[index]) {\n                    // Shift all values to the right of the current index left by one\n                    for (let i = index; i < length - 1; i++) {\n                        this.inputValues[i] = this.inputValues[i + 1];\n                    }\n                    // Clear the last box\n                    this.inputValues[length - 1] = '';\n                    // Update all inputRefs to match inputValues\n                    for (let i = 0; i < length; i++) {\n                        this.inputRefs[i].value = this.inputValues[i] || '';\n                    }\n                    this.updateValue(event);\n                    event.preventDefault();\n                }\n                else if (!this.inputValues[index] && index > 0) {\n                    // If current input is empty, move to previous input\n                    this.focusPrevious(index);\n                }\n            }\n            else if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {\n                this.isKeyboardNavigation = true;\n                event.preventDefault();\n                const isLeft = event.key === 'ArrowLeft';\n                const shouldMoveNext = (isLeft && rtl) || (!isLeft && !rtl);\n                // Only allow moving to the next input if the current has a value\n                if (shouldMoveNext) {\n                    if (this.inputValues[index] && index < length - 1) {\n                        this.focusNext(index);\n                    }\n                }\n                else {\n                    this.focusPrevious(index);\n                }\n            }\n            else if (event.key === 'Tab') {\n                this.isKeyboardNavigation = true;\n                // Let all tab events proceed normally\n                return;\n            }\n        };\n        /**\n         * Processes all input scenarios for each input box.\n         *\n         * This function manages:\n         * 1. Autofill handling\n         * 2. Input validation\n         * 3. Full selection replacement or typing in an empty box\n         * 4. Inserting in the middle with available space (shifting)\n         * 5. Single character replacement\n         */\n        this.onInput = (index) => (event) => {\n            var _a, _b;\n            const { length, validKeyPattern } = this;\n            const input = event.target;\n            const value = input.value;\n            const previousValue = this.previousInputValues[index] || '';\n            // 1. Autofill handling\n            // If the length of the value increases by more than 1 from the previous\n            // value, treat this as autofill. This is to prevent the case where the\n            // user is typing a single character into an input box containing a value\n            // as that will trigger this function with a value length of 2 characters.\n            const isAutofill = value.length - previousValue.length > 1;\n            if (isAutofill) {\n                // Distribute valid characters across input boxes\n                const validChars = value\n                    .split('')\n                    .filter((char) => validKeyPattern.test(char))\n                    .slice(0, length);\n                // If there are no valid characters coming from the\n                // autofill, all input refs have to be cleared after the\n                // browser has finished the autofill behavior\n                if (validChars.length === 0) {\n                    requestAnimationFrame(() => {\n                        this.inputRefs.forEach((input) => {\n                            input.value = '';\n                        });\n                    });\n                }\n                for (let i = 0; i < length; i++) {\n                    this.inputValues[i] = validChars[i] || '';\n                    this.inputRefs[i].value = validChars[i] || '';\n                }\n                this.updateValue(event);\n                // Focus the first empty input box or the last input box if all boxes\n                // are filled after a small delay to ensure the input boxes have been\n                // updated before moving the focus\n                setTimeout(() => {\n                    var _a;\n                    const nextIndex = validChars.length < length ? validChars.length : length - 1;\n                    (_a = this.inputRefs[nextIndex]) === null || _a === void 0 ? void 0 : _a.focus();\n                }, 20);\n                this.previousInputValues = [...this.inputValues];\n                return;\n            }\n            // 2. Input validation\n            // If the character entered is invalid (does not match the pattern),\n            // restore the previous value and exit\n            if (value.length > 0 && !validKeyPattern.test(value[value.length - 1])) {\n                input.value = this.inputValues[index] || '';\n                this.previousInputValues = [...this.inputValues];\n                return;\n            }\n            // 3. Full selection replacement or typing in an empty box\n            // If the user selects all text in the input box and types, or if the\n            // input box is empty, replace only this input box. If the box is empty,\n            // move to the next box, otherwise stay focused on this box.\n            const isAllSelected = input.selectionStart === 0 && input.selectionEnd === value.length;\n            const isEmpty = !this.inputValues[index];\n            if (isAllSelected || isEmpty) {\n                this.inputValues[index] = value;\n                input.value = value;\n                this.updateValue(event);\n                this.focusNext(index);\n                this.previousInputValues = [...this.inputValues];\n                return;\n            }\n            // 4. Inserting in the middle with available space (shifting)\n            // If typing in a filled input box and there are empty boxes at the end,\n            // shift all values starting at the current box to the right, and insert\n            // the new character at the current box.\n            const hasAvailableBoxAtEnd = this.inputValues[this.inputValues.length - 1] === '';\n            if (this.inputValues[index] && hasAvailableBoxAtEnd && value.length === 2) {\n                // Get the inserted character (from event or by diffing value/previousValue)\n                let newChar = event.data;\n                if (!newChar) {\n                    newChar = value.split('').find((c, i) => c !== previousValue[i]) || value[value.length - 1];\n                }\n                // Validate the new character before shifting\n                if (!validKeyPattern.test(newChar)) {\n                    input.value = this.inputValues[index] || '';\n                    this.previousInputValues = [...this.inputValues];\n                    return;\n                }\n                // Shift values right from the end to the insertion point\n                for (let i = this.inputValues.length - 1; i > index; i--) {\n                    this.inputValues[i] = this.inputValues[i - 1];\n                    this.inputRefs[i].value = this.inputValues[i] || '';\n                }\n                this.inputValues[index] = newChar;\n                this.inputRefs[index].value = newChar;\n                this.updateValue(event);\n                this.previousInputValues = [...this.inputValues];\n                return;\n            }\n            // 5. Single character replacement\n            // Handles replacing a single character in a box containing a value based\n            // on the cursor position. We need the cursor position to determine which\n            // character was the last character typed. For example, if the user types \"2\"\n            // in an input box with the cursor at the beginning of the value of \"6\",\n            // the value will be \"26\", but we want to grab the \"2\" as the last character\n            // typed.\n            const cursorPos = (_a = input.selectionStart) !== null && _a !== void 0 ? _a : value.length;\n            const newCharIndex = cursorPos - 1;\n            const newChar = (_b = value[newCharIndex]) !== null && _b !== void 0 ? _b : value[0];\n            // Check if the new character is valid before updating the value\n            if (!validKeyPattern.test(newChar)) {\n                input.value = this.inputValues[index] || '';\n                this.previousInputValues = [...this.inputValues];\n                return;\n            }\n            this.inputValues[index] = newChar;\n            input.value = newChar;\n            this.updateValue(event);\n            this.previousInputValues = [...this.inputValues];\n        };\n        /**\n         * Handles pasting text into the input OTP component.\n         * This function prevents the default paste behavior and\n         * validates the pasted text against the allowed pattern.\n         * It then updates the value of the input group and focuses\n         * the next empty input after pasting.\n         */\n        this.onPaste = (event) => {\n            var _a, _b;\n            const { inputRefs, length, validKeyPattern } = this;\n            event.preventDefault();\n            const pastedText = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text');\n            // If there is no pasted text, still emit the input change event\n            // because this is how the native input element behaves\n            // but return early because there is nothing to paste.\n            if (!pastedText) {\n                this.emitIonInput(event);\n                return;\n            }\n            const validChars = pastedText\n                .split('')\n                .filter((char) => validKeyPattern.test(char))\n                .slice(0, length);\n            // Always paste starting at the first box\n            validChars.forEach((char, index) => {\n                if (index < length) {\n                    this.inputRefs[index].value = char;\n                    this.inputValues[index] = char;\n                }\n            });\n            // Update the value so that all input boxes are updated\n            this.value = validChars.join('');\n            this.updateValue(event);\n            // Focus the next empty input after pasting\n            // If all boxes are filled, focus the last input\n            const nextEmptyIndex = validChars.length < length ? validChars.length : length - 1;\n            (_b = inputRefs[nextEmptyIndex]) === null || _b === void 0 ? void 0 : _b.focus();\n        };\n    }\n    /**\n     * Sets focus to an input box.\n     * @param index - The index of the input box to focus (0-based).\n     * If provided and the input box has a value, the input box at that index will be focused.\n     * Otherwise, the first empty input box or the last input if all are filled will be focused.\n     */\n    async setFocus(index) {\n        var _a, _b;\n        if (typeof index === 'number') {\n            const validIndex = Math.max(0, Math.min(index, this.length - 1));\n            (_a = this.inputRefs[validIndex]) === null || _a === void 0 ? void 0 : _a.focus();\n        }\n        else {\n            const tabbableIndex = this.getTabbableIndex();\n            (_b = this.inputRefs[tabbableIndex]) === null || _b === void 0 ? void 0 : _b.focus();\n        }\n    }\n    valueChanged() {\n        this.initializeValues();\n        this.updateTabIndexes();\n    }\n    /**\n     * Processes the separators prop into an array of numbers.\n     *\n     * If the separators prop is not provided, returns an empty array.\n     * If the separators prop is 'all', returns an array of all valid positions (1 to length-1).\n     * If the separators prop is an array, returns it as is.\n     * If the separators prop is a string, splits it by commas and parses each part as a number.\n     *\n     * If the separators are greater than the input length, it will warn and ignore the separators.\n     */\n    processSeparators() {\n        const { separators, length } = this;\n        if (separators === undefined) {\n            this.parsedSeparators = [];\n            return;\n        }\n        if (typeof separators === 'string' && separators !== 'all') {\n            const isValidFormat = /^(\\d+)(,\\d+)*$/.test(separators);\n            if (!isValidFormat) {\n                printIonWarning(`[ion-input-otp] - Invalid separators format. Expected a comma-separated list of numbers, an array of numbers, or \"all\". Received: ${separators}`, this.el);\n                this.parsedSeparators = [];\n                return;\n            }\n        }\n        let separatorValues;\n        if (separators === 'all') {\n            separatorValues = Array.from({ length: length - 1 }, (_, i) => i + 1);\n        }\n        else if (Array.isArray(separators)) {\n            separatorValues = separators;\n        }\n        else {\n            separatorValues = separators\n                .split(',')\n                .map((pos) => parseInt(pos, 10))\n                .filter((pos) => !isNaN(pos));\n        }\n        // Check for duplicate separator positions\n        const duplicates = separatorValues.filter((pos, index) => separatorValues.indexOf(pos) !== index);\n        if (duplicates.length > 0) {\n            printIonWarning(`[ion-input-otp] - Duplicate separator positions are not allowed. Received: ${separators}`, this.el);\n        }\n        const invalidSeparators = separatorValues.filter((pos) => pos > length);\n        if (invalidSeparators.length > 0) {\n            printIonWarning(`[ion-input-otp] - The following separator positions are greater than the input length (${length}): ${invalidSeparators.join(', ')}. These separators will be ignored.`, this.el);\n        }\n        this.parsedSeparators = separatorValues.filter((pos) => pos <= length);\n    }\n    componentWillLoad() {\n        this.inheritedAttributes = inheritAriaAttributes(this.el);\n        this.processSeparators();\n        this.initializeValues();\n    }\n    componentDidLoad() {\n        this.updateTabIndexes();\n    }\n    /**\n     * Get the regex pattern for allowed characters.\n     * If a pattern is provided, use it to create a regex pattern\n     * Otherwise, use the default regex pattern based on type\n     */\n    get validKeyPattern() {\n        return new RegExp(`^${this.getPattern()}$`, 'u');\n    }\n    /**\n     * Gets the string pattern to pass to the input element\n     * and use in the regex for allowed characters.\n     */\n    getPattern() {\n        const { pattern, type } = this;\n        if (pattern) {\n            return pattern;\n        }\n        return type === 'number' ? '[\\\\p{N}]' : '[\\\\p{L}\\\\p{N}]';\n    }\n    /**\n     * Get the default value for inputmode.\n     * If inputmode is provided, use it.\n     * Otherwise, use the default inputmode based on type\n     */\n    getInputmode() {\n        const { inputmode } = this;\n        if (inputmode) {\n            return inputmode;\n        }\n        if (this.type == 'number') {\n            return 'numeric';\n        }\n        else {\n            return 'text';\n        }\n    }\n    /**\n     * Initializes the input values array based on the current value prop.\n     * This splits the value into individual characters and validates them against\n     * the allowed pattern. The values are then used as the values in the native\n     * input boxes and the value of the input group is updated.\n     */\n    initializeValues() {\n        // Clear all input values\n        this.inputValues = Array(this.length).fill('');\n        // If the value is null, undefined, or an empty string, return\n        if (this.value == null || String(this.value).length === 0) {\n            return;\n        }\n        // Split the value into individual characters and validate\n        // them against the allowed pattern\n        const chars = String(this.value).split('').slice(0, this.length);\n        chars.forEach((char, index) => {\n            if (this.validKeyPattern.test(char)) {\n                this.inputValues[index] = char;\n            }\n        });\n        // Update the value without emitting events\n        this.value = this.inputValues.join('');\n        this.previousInputValues = [...this.inputValues];\n    }\n    /**\n     * Updates the value of the input group.\n     * This updates the value of the input group and emits an `ionChange` event.\n     * If all of the input boxes are filled, it emits an `ionComplete` event.\n     */\n    updateValue(event) {\n        const { inputValues, length } = this;\n        const newValue = inputValues.join('');\n        this.value = newValue;\n        this.emitIonInput(event);\n        if (newValue.length === length) {\n            this.ionComplete.emit({ value: newValue });\n        }\n    }\n    /**\n     * Emits an `ionChange` event.\n     * This API should be called for user committed changes.\n     * This API should not be used for external value changes.\n     */\n    emitIonChange(event) {\n        const { value } = this;\n        // Checks for both null and undefined values\n        const newValue = value == null ? value : value.toString();\n        this.ionChange.emit({ value: newValue, event });\n    }\n    /**\n     * Emits an `ionInput` event.\n     * This is used to emit the input value when the user types,\n     * backspaces, or pastes.\n     */\n    emitIonInput(event) {\n        const { value } = this;\n        // Checks for both null and undefined values\n        const newValue = value == null ? value : value.toString();\n        this.ionInput.emit({ value: newValue, event });\n    }\n    /**\n     * Focuses the next input box.\n     */\n    focusNext(currentIndex) {\n        var _a;\n        const { inputRefs, length } = this;\n        if (currentIndex < length - 1) {\n            (_a = inputRefs[currentIndex + 1]) === null || _a === void 0 ? void 0 : _a.focus();\n        }\n    }\n    /**\n     * Focuses the previous input box.\n     */\n    focusPrevious(currentIndex) {\n        var _a;\n        const { inputRefs } = this;\n        if (currentIndex > 0) {\n            (_a = inputRefs[currentIndex - 1]) === null || _a === void 0 ? void 0 : _a.focus();\n        }\n    }\n    /**\n     * Searches through the input values and returns the index\n     * of the first empty input.\n     * Returns -1 if all inputs are filled.\n     */\n    getFirstEmptyIndex() {\n        var _a;\n        const { inputValues, length } = this;\n        // Create an array of the same length as the input OTP\n        // and fill it with the input values\n        const values = Array.from({ length }, (_, i) => inputValues[i] || '');\n        return (_a = values.findIndex((value) => !value || value === '')) !== null && _a !== void 0 ? _a : -1;\n    }\n    /**\n     * Returns the index of the input that should be tabbed to.\n     * If all inputs are filled, returns the last input's index.\n     * Otherwise, returns the index of the first empty input.\n     */\n    getTabbableIndex() {\n        const { length } = this;\n        const firstEmptyIndex = this.getFirstEmptyIndex();\n        return firstEmptyIndex === -1 ? length - 1 : firstEmptyIndex;\n    }\n    /**\n     * Updates the tabIndexes for the input boxes.\n     * This is used to ensure that the correct input is\n     * focused when the user navigates using the tab key.\n     */\n    updateTabIndexes() {\n        const { inputRefs, inputValues, length } = this;\n        // Find first empty index after any filled boxes\n        let firstEmptyIndex = -1;\n        for (let i = 0; i < length; i++) {\n            if (!inputValues[i] || inputValues[i] === '') {\n                firstEmptyIndex = i;\n                break;\n            }\n        }\n        // Update tabIndex and aria-hidden for all inputs\n        inputRefs.forEach((input, index) => {\n            const shouldBeTabbable = firstEmptyIndex === -1 ? index === length - 1 : firstEmptyIndex === index;\n            input.tabIndex = shouldBeTabbable ? 0 : -1;\n            // If the input is empty and not the first empty input,\n            // it should be hidden from screen readers.\n            const isEmpty = !inputValues[index] || inputValues[index] === '';\n            input.setAttribute('aria-hidden', isEmpty && !shouldBeTabbable ? 'true' : 'false');\n        });\n    }\n    /**\n     * Determines if a separator should be shown for a given index by\n     * checking if the index is included in the parsed separators array.\n     */\n    showSeparator(index) {\n        const { length } = this;\n        return this.parsedSeparators.includes(index + 1) && index < length - 1;\n    }\n    render() {\n        var _a, _b;\n        const { autocapitalize, color, disabled, el, fill, hasFocus, inheritedAttributes, inputId, inputRefs, inputValues, length, readonly, shape, size, } = this;\n        const mode = getIonMode(this);\n        const inputmode = this.getInputmode();\n        const tabbableIndex = this.getTabbableIndex();\n        const pattern = this.getPattern();\n        const hasDescription = ((_b = (_a = el.querySelector('.input-otp-description')) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.trim()) !== '';\n        return (h(Host, { key: 'f15a29fb17b681ef55885ca36d3d5f899cbaca83', class: createColorClasses(color, {\n                [mode]: true,\n                'has-focus': hasFocus,\n                [`input-otp-size-${size}`]: true,\n                [`input-otp-shape-${shape}`]: true,\n                [`input-otp-fill-${fill}`]: true,\n                'input-otp-disabled': disabled,\n                'input-otp-readonly': readonly,\n            }) }, h(\"div\", Object.assign({ key: 'd7e1d4edd8aafcf2ed4313301287282e90fc7e82', role: \"group\", \"aria-label\": \"One-time password input\", class: \"input-otp-group\" }, inheritedAttributes), Array.from({ length }).map((_, index) => (h(Fragment, null, h(\"div\", { class: \"native-wrapper\" }, h(\"input\", { class: \"native-input\", id: `${inputId}-${index}`, \"aria-label\": `Input ${index + 1} of ${length}`, type: \"text\", autoCapitalize: autocapitalize, inputmode: inputmode, pattern: pattern, disabled: disabled, readOnly: readonly, tabIndex: index === tabbableIndex ? 0 : -1, value: inputValues[index] || '', autocomplete: \"one-time-code\", ref: (el) => (inputRefs[index] = el), onInput: this.onInput(index), onBlur: this.onBlur, onFocus: this.onFocus(index), onKeyDown: this.onKeyDown(index), onPaste: this.onPaste })), this.showSeparator(index) && h(\"div\", { class: \"input-otp-separator\" }))))), h(\"div\", { key: '3724a3159d02860971879a906092f9965f5a7c47', class: {\n                'input-otp-description': true,\n                'input-otp-description-hidden': !hasDescription,\n            } }, h(\"slot\", { key: '11baa2624926a08274508afe0833d9237a8dc35c' }))));\n    }\n    get el() { return getElement(this); }\n    static get watchers() { return {\n        \"value\": [\"valueChanged\"],\n        \"separators\": [\"processSeparators\"],\n        \"length\": [\"processSeparators\"]\n    }; }\n};\nlet inputIds = 0;\nInputOTP.style = {\n    ios: inputOtpIosCss,\n    md: inputOtpMdCss\n};\n\nexport { InputOTP as ion_input_otp };\n"],"x_google_ignoreList":[0,1]}