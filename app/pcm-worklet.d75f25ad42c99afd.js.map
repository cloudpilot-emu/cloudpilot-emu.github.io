{"version":3,"file":"pcm-worklet.d75f25ad42c99afd.js","mappings":"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","names":["SampleQueue","constructor","capacity","sampleRateFrom","sampleRateTo","this","length","nextSample","currentSampleIndex","currentSampleLeft","currentSampleRight","channelLeftData","Float32Array","channelRightData","push","sample","fill","channelLeft","channelRight","iIn","iOut","increment","clear","PcmProcessor","AudioWorkletProcessor","options","super","onStreamMessage","e","message","data","type","count","samples","Uint32Array","buffer","i","sampleQueue","dispatchStreamMessage","flush","onControlMessage","setStreamPort","port","clearStreamPort","buffering","backpressure","processorOptions","addEventListener","start","console","log","process","inputs","outputs","len","transferables","streamPort","postMessage","removeEventListener","undefined","registerProcessor"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./common/service/audioworklet/pcm-worklet.worker.ts"],"sourcesContent":["/// <reference lib=\"webworker\" />\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"./audioworklet.d.ts\"/>\n//\nimport {\n    ControlMessageHost,\n    ControlMessageHostType,\n    StreamMessageClient,\n    StreamMessageClientType,\n    StreamMessageHost,\n    StreamMessageHostType,\n} from './messages';\nimport { PcmProcessorOptions, ProcessorNodeOptions } from './options';\nimport { WorkletType } from './worklet-types';\n\nclass SampleQueue {\n    constructor(\n        private capacity: number,\n        private sampleRateFrom: number,\n        private sampleRateTo: number,\n    ) {\n        this.channelLeftData = new Float32Array(this.capacity);\n        this.channelRightData = new Float32Array(this.capacity);\n    }\n\n    push(sample: number) {\n        this.channelLeftData[this.nextSample] = ((sample << 16) >> 16) / 0x7fff;\n        this.channelRightData[this.nextSample] = (sample >> 16) / 0x7fff;\n\n        if (this.length < this.capacity) {\n            this.length++;\n        }\n\n        this.nextSample = (this.nextSample + 1) % this.capacity;\n    }\n\n    fill(channelLeft: Float32Array, channelRight: Float32Array) {\n        const length = channelLeft.length;\n        if (length !== channelRight.length) return;\n\n        let iIn = (this.nextSample - this.length + this.capacity) % this.capacity;\n\n        if (this.sampleRateFrom === this.sampleRateTo) {\n            for (let iOut = 0; iOut < length && this.length > 0; iOut++) {\n                channelLeft[iOut] = this.channelLeftData[iIn];\n                channelRight[iOut] = this.channelRightData[iIn];\n\n                iIn = (iIn + 1) % this.capacity;\n                this.length--;\n            }\n        } else {\n            for (let iOut = 0; iOut < length && this.length > 0; iOut++) {\n                this.currentSampleIndex += this.sampleRateFrom;\n\n                if (this.currentSampleIndex > this.sampleRateTo) {\n                    this.currentSampleLeft = this.channelLeftData[iIn];\n                    this.currentSampleRight = this.channelRightData[iIn];\n\n                    let increment = (this.currentSampleIndex / this.sampleRateTo) | 0;\n                    if (increment > this.length) increment = this.length;\n\n                    iIn = (iIn + increment) % this.capacity;\n                    this.currentSampleIndex %= this.sampleRateTo;\n                    this.length -= increment;\n                }\n\n                channelLeft[iOut] = this.currentSampleLeft;\n                channelRight[iOut] = this.currentSampleRight;\n            }\n        }\n    }\n\n    clear() {\n        this.length = 0;\n    }\n\n    length = 0;\n    private nextSample = 0;\n\n    private channelLeftData: Float32Array;\n    private channelRightData: Float32Array;\n\n    private currentSampleIndex = 0;\n    private currentSampleLeft = 0;\n    private currentSampleRight = 0;\n}\n\nclass PcmProcessor extends AudioWorkletProcessor implements AudioWorkletProcessorImpl {\n    constructor(options: ProcessorNodeOptions<PcmProcessorOptions>) {\n        super();\n\n        const sampleRateTo = options.processorOptions.sampleRateTo;\n\n        this.sampleQueue = new SampleQueue((44100 / 60) * 10, 44100, sampleRateTo);\n        this.buffering = true;\n        this.backpressure = false;\n\n        this.port.addEventListener('message', this.onControlMessage);\n        this.port.start();\n\n        console.log(`pcm worklet initialized at ${sampleRateTo}Hz`);\n    }\n\n    process(inputs: Float32Array[][], outputs: Float32Array[][]): boolean {\n        if (outputs.length !== 1 || outputs[0].length !== 2) return false;\n        const len = outputs[0][0].length;\n\n        if (this.buffering && this.sampleQueue.length > (44100 / 60) * 4) {\n            this.buffering = false;\n        }\n\n        if (!this.buffering && this.sampleQueue.length < len) {\n            this.buffering = true;\n        }\n\n        if (this.backpressure && this.sampleQueue.length < (44100 / 60) * 7) {\n            this.backpressure = false;\n            this.dispatchStreamMessage({ type: StreamMessageClientType.resumePcm });\n        }\n\n        if (!this.backpressure && this.sampleQueue.length > (44100 / 60) * 8) {\n            this.backpressure = true;\n            this.dispatchStreamMessage({ type: StreamMessageClientType.suspendPcm });\n        }\n\n        if (!this.buffering) this.sampleQueue.fill(outputs[0][0], outputs[0][1]);\n\n        return true;\n    }\n\n    private dispatchStreamMessage(message: StreamMessageClient, transferables?: Array<Transferable>) {\n        this.streamPort?.postMessage(message, transferables as Array<Transferable>);\n    }\n\n    private onStreamMessage = (e: MessageEvent) => {\n        const message: StreamMessageHost = e.data;\n\n        switch (message.type) {\n            case StreamMessageHostType.sampleData: {\n                const count = message.count;\n                const samples = new Uint32Array(message.buffer);\n\n                for (let i = 0; i < count; i++) this.sampleQueue.push(samples[i]);\n\n                this.dispatchStreamMessage({ type: StreamMessageClientType.returnBuffer, buffer: message.buffer }, [\n                    message.buffer,\n                ]);\n\n                break;\n            }\n\n            case StreamMessageHostType.flush:\n                this.flush();\n                this.dispatchStreamMessage({ type: StreamMessageClientType.resumePcm });\n\n                break;\n\n            default:\n                message satisfies never;\n        }\n    };\n\n    private onControlMessage = (e: MessageEvent) => {\n        const message: ControlMessageHost = e.data;\n\n        switch (message.type) {\n            case ControlMessageHostType.setStreamMessagePort: {\n                this.setStreamPort(message.port);\n                break;\n            }\n\n            case ControlMessageHostType.flush:\n                this.flush();\n                this.dispatchStreamMessage({ type: StreamMessageClientType.resumePcm });\n\n                break;\n\n            case ControlMessageHostType.reset:\n                this.clearStreamPort();\n\n                break;\n\n            default:\n                message satisfies never;\n        }\n    };\n\n    private flush(): void {\n        this.buffering = true;\n        this.backpressure = false;\n\n        this.sampleQueue.clear();\n    }\n\n    private clearStreamPort(): void {\n        if (this.streamPort) this.streamPort.removeEventListener('message', this.onStreamMessage);\n        this.streamPort = undefined;\n\n        this.flush();\n    }\n\n    private setStreamPort(port: MessagePort): void {\n        this.clearStreamPort();\n\n        this.streamPort = port;\n        this.streamPort.addEventListener('message', this.onStreamMessage);\n        this.streamPort.start();\n    }\n\n    private sampleQueue: SampleQueue;\n    private buffering = true;\n    private backpressure = false;\n\n    private streamPort: MessagePort | undefined;\n}\n\nregisterProcessor(WorkletType.pcmProcessor, PcmProcessor);\n"],"x_google_ignoreList":[]}